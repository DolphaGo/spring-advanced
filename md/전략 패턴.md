- [전략 패턴](#전략-패턴)
  - [전략 패턴 - 시작](#전략-패턴---시작)
  - [전략 패턴 - 예제 1](#전략-패턴---예제-1)

---

# 전략 패턴
## 전략 패턴 - 시작

- 이전에 템플릿 메서드 패턴에서 겪었던, **변하는 부분**과 **변하지 않는 부분** 이 섞여 있는 상황을 보자.

```java
@Slf4j
public class ContextV1Test {
    
    @Test
    void strategyV0() {
        logic1();
        logic2();
    }

    private void logic1() {
        final long startTime = System.currentTimeMillis();
        // 비즈니스 로직 실행
        log.info("비즈니스 로직1 실행");
        // 비즈니스 로직 종료
        final long endTime = System.currentTimeMillis();
        final long resultTime = endTime - startTime;
        log.info("resultTime = {}", resultTime);
    }

    private void logic2() {
        final long startTime = System.currentTimeMillis();
        // 비즈니스 로직 실행
        log.info("비즈니스 로직2 실행");
        // 비즈니스 로직 종료
        final long endTime = System.currentTimeMillis();
        final long resultTime = endTime - startTime;
        log.info("resultTime = {}", resultTime);
    }
}
```

## 전략 패턴 - 예제 1

- 동일한 문제를 전략 패턴을 사용해서 해결해보자.
- 템플릿 메서드 패턴은 부모 클래스에 변하지 않는 템플릿을 두고, 변하는 부분을 자식 클래스에 두어서 상속을 사용해서 문제를 해결했다.
- **전략 패턴은 변하지 않는 부분을 Context라는 곳에 두고, 변하는 부분을 Strategy라는 인터페이스를 만들고, 해당 인터페이스를 구현하도록 해서 문제를 해결한다.**
- **즉, 상속이 아니라, 위임으로 문제를 해결하는 것이다.**
- **전략 패턴에서 `Context` 는 변하지 않는 템플릿 역할을 하고, `Strategy` 는 변하는 알고리즘 역할을 한다.**


> GOF 디자인 패턴에서 정의한 전략 패턴의 의도는 다음과 같다.

- 알고리즘 제품군을 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만들자.
- 전략을 사용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있다.

![](/images/2022-04-25-03-42-39.png)

```java
public interface Strategy {
    void call();
}
```

```java
@Slf4j
public class StrategyLogic1 implements Strategy {
    @Override
    public void call() {
        log.info("비즈니스 로직1 실행");
    }
}
```

```java
@Slf4j
public class StrategyLogic2 implements Strategy {
    @Override
    public void call() {
        log.info("비즈니스 로직2 실행");
    }
}
```

- 변하는 알고리즘은 `Strategy` 인터페이스를 구현하면 된다.

```java
/**
 * 필드에 전략을 보관하는 방식
 */
@Slf4j
public class ContextV1 {

    private Strategy strategy;

    public ContextV1(final Strategy strategy) {
        this.strategy = strategy;
    }

    public void execute() {
        final long startTime = System.currentTimeMillis();
        // 비즈니스 로직 실행
        strategy.call(); // 위임
        // 비즈니스 로직 종료
        final long endTime = System.currentTimeMillis();
        final long resultTime = endTime - startTime;
        log.info("resultTime = {}", resultTime);
    }
}
```

- ContextV1은 변하지 않는 로직을 가지고 있는 템플릿 역할을 하는 코드이다.
- 전략 패턴에서는 이를 컨텍스트(문맥)이라고 한다.
- 쉽게 이야기해서 컨텍스트(문맥)는 변하지 않지만, 그 문맥 속에서 strategy를 통해 일부 전략이 변경된다 생각하면 된다.
- `Context`는 내부에 `Strategy strategy` 필드를 갖고 있다.
- 이 필드에 변하는 부분인 Strategy 의 구현체를 주입하면 된다.
- **전략 패턴의 핵심은 `Context`는 `Strategy` 인터페이스에만 의존한다는 점**이다.
- **덕분에 `Strategy` 구현체를 변경하거나, 새로 만들어도 `Context` 코드에는 영향을 주지 않는다!**
- 스프링에서 의존관계 주입하는 방식이 바로 전략 패턴이다.

```java
@DisplayName("전략 패턴 사용")
@Test
void strategyV1() {
    StrategyLogic1 strategyLogic1 = new StrategyLogic1();
    ContextV1 context1 = new ContextV1(strategyLogic1);
    context1.execute();

    StrategyLogic2 strategyLogic2 = new StrategyLogic2();
    ContextV1 context2 = new ContextV1(strategyLogic2);
    context2.execute();
}
```

- 위와 같이 Context 안에 원하는 전략을 주입한다.
- 이렇게 원하는 모양으로 조립하고 난 뒤 context.execute() 를 호출해서 context를 실행한다.

![](/images/2022-04-25-03-55-13.png)

- 이전의 [템플릿 메서드 패턴](템플릿%20메서드%20패턴.md)에서는 상속을 썼지만, 이제 의존하는 것이 오로지 인터페이스뿐이다.
- 상속보다는 Context에서도 인터페이스의 위임을 통해 코드를 안정적으로 유지/보수 할 수 있게 된다.

