- [스프링 AOP - 실무 주의 사항](#스프링-aop---실무-주의-사항)
  - [프록시와 내부 호출](#프록시와-내부-호출)
    - [문제](#문제)
    - [대안 1 : 자기 자신 주입](#대안-1--자기-자신-주입)
    - [대안 2 : 지연 조회](#대안-2--지연-조회)
    - [대안 3 : 구조 변경](#대안-3--구조-변경)
  - [프록시 기술과 한계](#프록시-기술과-한계)
    - [타입 캐스팅](#타입-캐스팅)
    - [의존 관계 주입](#의존-관계-주입)
    - [CGLIB](#cglib)
    - [스프링의 해결책](#스프링의-해결책)

---

# 스프링 AOP - 실무 주의 사항

## 프록시와 내부 호출

### 문제

- 스프링은 프록시 방식의 AOP를 사용한다.
- 따라서 AOP를 적용하려면, **항상 프록시를 통해서 대상 객체(Target)을 호출해야 한다.**
- 이렇게 해야 프록시에서 먼저 어드바이스를 호출하고, 이후에 대상 객체를 호출한다.
- 만약 프록시를 거치지 않고 대상 객체를 직접 호출하게 되면, AOP가 적용되지 않고, 어드바이스도 호출되지 않는다.

**AOP를 적용하면 스프링은 대상 객체 대신에 프록시를 스프링 빈으로 등록한다.**

- 따라서 스프링은 의존관계 주입시에 항상 프록시 객체를 주입한다.
- 프록시 객체가 주입되기 때문에 대상 객체를 직접 호출하는 문제는 일반적으로 발생하지는 않는다.
- 하지만 **대상 객체의 내부에서 메서드 호출이 발생하면, 프록시를 거치지 않고 대상 객체를 직접 호출하는 문제가 발생한다.**
- 실무에서 반드시 한 번만 만나서 고생하는 문제이기 때문에 꼭 이해하고 넘어가보자.

예제를 통해 내부 호출이 발생할 때, 어떤 문제가 발생하는지 알아보자.
먼저 내부 호출이 발생하는 예제를 만들어보자.

```java
@Slf4j
@Component
public class CallServiceV0 {

    // 외부에서 호출
    public void external() {
        log.info("call external");
        internal(); // 내부 메서드 호출(this.internal()) 참고로 자바에서 this를 생략하면, 자기 자신의 인스턴스를 의미한다.
    }

    public void internal() {
        log.info("call internal");
    }
}
```

- `CallServiceV0.external()` 을 호출하면 내부에서 `internal()` 이라는 자기 자신의 메서드를 호출한다.
- 자바 언어에서 메서드를 호출할 때 대상을 지정하지 않으면 앞에 자기 자신의 인스턴스를 뜻하는 `this` 가 붙게 된다.
- 그러니까 여기서는 `this.internal()` 이라고 이해하면 된다.

이제 Aspect를 만들어보자.

```java
@Slf4j
@Aspect
public class CallLogAspect {

    @Before("execution(* hello.aop.internalcall..*.*(..))")
    public void doLog(JoinPoint joinPoint) {
        log.info("aop={}", joinPoint.getSignature());
    }
}
```

> 테스트

```java
@Slf4j
@Import(CallLogAspect.class)
@SpringBootTest
class CallServiceV0Test {

    @Autowired
    CallServiceV0 callServiceV0;

    @Test
    void external() {
//        log.info("target={}", callServiceV0.getClass()); // CGLIB Proxy
        callServiceV0.external();
    }

    @Test
    void internal() {
        callServiceV0.internal();
    }
}
```

- 실행 결과

> **`external()`을 호출했을 때**

```log
2022-05-24 03:16:40.577  INFO 58810 --- [    Test worker] h.aop.internalcall.aop.CallLogAspect     : aop=void hello.aop.internalcall.CallServiceV0.external()
2022-05-24 03:16:40.588  INFO 58810 --- [    Test worker] hello.aop.internalcall.CallServiceV0     : call external
2022-05-24 03:16:40.588  INFO 58810 --- [    Test worker] hello.aop.internalcall.CallServiceV0     : call internal
```

> 실행결과 분석

![](/images/2022-05-24-03-17-47.png)

- 실행 결과를 보면 `callServiceV0.external()` 을 실행할 때는 프록시를 호출한다. 
- 따라서 `CallLogAspect` 어드바이스가 호출된 것을 확인할 수 있다.
- 그리고 AOP Proxy는 `target.external()` 을 호출한다.
- **그런데 여기서 문제는 `callServiceV0.external()` 안에서 internal() 을 호출할 때 발생한다. 이때는 CallLogAspect 어드바이스가 호출되지 않는다.**
- 자바 언어에서 메서드 앞에 별도의 참조가 없으면 `this` 라는 뜻으로 자기 자신의 인스턴스를 가리킨다. 
- 결과적으로 **자기 자신의 내부 메서드를 호출하는 `this.internal()` 이 되는데, 여기서 `this` 는 실제 대상 객체(target)의 인스턴스를 뜻한다.** 
- **결과적으로 이러한 내부 호출은 프록시를 거치지 않는다. 따라서 어드바이스도 적용할 수 없다.**


> **`internal()`을 호출했을 때**

```log
2022-05-24 03:17:00.070  INFO 58886 --- [    Test worker] h.aop.internalcall.aop.CallLogAspect     : aop=void hello.aop.internalcall.CallServiceV0.internal()
2022-05-24 03:17:00.080  INFO 58886 --- [    Test worker] hello.aop.internalcall.CallServiceV0     : call internal
```

![](/images/2022-05-24-03-19-28.png)

- 외부에서 호출하는 경우 프록시를 거치기 때문에 `internal()` 도 `CallLogAspect` 어드바이스가 적용된 것을 확인할 수 있다.


> **프록시 방식의 AOP 한계**

- 스프링은 프록시 방식의 AOP를 사용한다.
- 프록시 방식의 AOP는 메서드 내부 호출에 프록시를 적용할 수 없다.
- 지금부터 이 문제를 해결하는 방법을 하나씩 알아보자.

> *참고*

- 실제 코드에 AOP를 직접 적용하는 AspectJ를 사용하면 이런 문제가 발생하지 않는다.
- 프록시를 통하는 것이 아니라 해당 코드에 직접 AOP 적용 코드가 붙어 있기 때문에 내부 호출과 무관하게 AOP를 적용할 수 있다.
- 하지만 로드 타임 위빙 등을 사용해야 하는데, 설정이 복잡하고 JVM 옵션을 주어야 하는 부담이 있다. 
- 그리고 지금부터 설명할 프록시 방식의 AOP에서 내부 호출에 대응할 수 있는 대안들도 있다.
- 이런 이유로 AspectJ를 직접 사용하는 방법은 실무에서는 거의 사용하지 않는다.
- 스프링 애플리케이션과 함께 직접 AspectJ 사용하는 방법은 [스프링 공식 메뉴얼](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-using-aspectj)을 참고하자.

### 대안 1 : 자기 자신 주입

- 내부 호출을 해결하는 가장 간단한 방법은, 자기 자신을 의존관계 주입 받는 것이다.

> Service

```java
@Slf4j
@Component
public class CallServiceV1 {

    private CallServiceV1 callServiceV1;

    // 생성자 주입을 쓰면 문제가 생긴다 (순환 참조 문제) : 자기 자신을 또 자기 자신한테 주입받으려고 하기 때문이다.(자기 자신이 생성도 안됐는데)

    @Autowired
    public void setCallServiceV1(final CallServiceV1 callServiceV1) {
        log.info("callServiceV1 setter={}", callServiceV1.getClass()); // 프록시가 주입이 된다.
        this.callServiceV1 = callServiceV1; // 생성이 다 끝나고 세터로 자기 자신을 호출하도록 하면 됩니다.
    }

    // 외부에서 호출
    public void external() {
        log.info("call external");
        callServiceV1.internal();
    }

    public void internal() {
        log.info("call internal");
    }
}
```

- 위에서 순환 참조 문제를 피하려 생성자 방식 대신 세터 방식을 활용했지만 스프링 부트 2.6.0 버전부터는 세터마저 아예 막히도록 되었는데, 이를 해결하는 방법으로는 application.yml(properties) 에 다음 설정을 추가해주면 된다.

```yml
spring:
  main:
    allow-circular-references: true
```

> 테스트

```java
@Import(CallLogAspect.class)
@SpringBootTest
class CallServiceV1Test {
    @Autowired
    CallServiceV1 callServiceV1;

    @Test
    void external() {
        callServiceV1.external();
    }
}
```

- `callServiceV1` 를 수정자를 통해서 주입 받는 것을 확인할 수 있다.
- **스프링에서 AOP가 적용된 대상을 의존관계 주입 받으면 주입 받은 대상은 실제 자신이 아니라 프록시 객체이다.**
- `external()` 을 호출하면 `callServiceV1.internal()`를 호출하게 된다.
- 주입받은 `callServiceV1`은 프록시이다. 따라서 프록시를 통해서 AOP를 적용할 수 있다.

<br/>

> 실행 결과 및 분석

```log
2022-05-24 03:29:39.286  INFO 61803 --- [    Test worker] h.aop.internalcall.aop.CallLogAspect     : aop=void hello.aop.internalcall.CallServiceV1.external()
2022-05-24 03:29:39.294  INFO 61803 --- [    Test worker] hello.aop.internalcall.CallServiceV1     : call external
2022-05-24 03:29:39.295  INFO 61803 --- [    Test worker] h.aop.internalcall.aop.CallLogAspect     : aop=void hello.aop.internalcall.CallServiceV1.internal()
2022-05-24 03:29:39.295  INFO 61803 --- [    Test worker] hello.aop.internalcall.CallServiceV1     : call internal
```

![](/images/2022-05-24-03-23-44.png)

- 실행 결과를 보면 **이제는 `internal()` 을 호출할 때 자기 자신의 인스턴스를 호출하는 것이 아니라 프록시 인스턴스를 통해서 호출하는 것을 확인할 수 있다.** 당연히 AOP도 잘 적용된다.

### 대안 2 : 지연 조회

- 앞서 생성자 주입이 실패하는 이유는 자기 자신을 생성하면서 주입해야 하기 때문이다.
- 이 경우 수정자 주입을 사용하거나 지금부터 설명하는 지연 조회를 사용하면 된다.
- 스프링 빈을 지연해서 조회하면 되는데, `ObjectProvider(Provider)`, `ApplicationContext`를 사용하면 된다.

```java
@Slf4j
@Component
public class CallServiceV2 {

    private final ApplicationContext applicationContext; // applicationContext는 주입 받을 수 있도록 스프링이 제공해준다.

    public CallServiceV2(final ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }

    // 외부에서 호출
    public void external() {
        log.info("call external");
        final CallServiceV2 callServiceV2 = applicationContext.getBean(CallServiceV2.class);
        callServiceV2.internal(); // 외부 메서드 호출
    }

    public void internal() {
        log.info("call internal");
    }
}
```

> 테스트

```java
@Import(CallLogAspect.class)
@SpringBootTest
class CallServiceV2Test {
    @Autowired
    CallServiceV2 callServiceV2;

    @Test
    void external() {
        callServiceV2.external();
    }
}
```

> 실행 결과

```java
2022-05-24 03:36:27.726  INFO 63517 --- [    Test worker] h.aop.internalcall.aop.CallLogAspect     : aop=void hello.aop.internalcall.CallServiceV2.external()
2022-05-24 03:36:27.734  INFO 63517 --- [    Test worker] hello.aop.internalcall.CallServiceV2     : call external
2022-05-24 03:36:27.735  INFO 63517 --- [    Test worker] h.aop.internalcall.aop.CallLogAspect     : aop=void hello.aop.internalcall.CallServiceV2.internal()
2022-05-24 03:36:27.735  INFO 63517 --- [    Test worker] hello.aop.internalcall.CallServiceV2     : call internal
```

- 잘 동작한다. 그러나 ApplicationContext는 너무 거대한 녀석이다.
- 우리가 원하는 것은 이 수많은 기능들 중 딱 1가지, 지연해서 callServiceV2를 조회하는 것이다.
- ObjectProvider를 이용해보자.

```java
@Slf4j
@Component
public class CallServiceV2 {

    private final ObjectProvider<CallServiceV2> callServiceProvider;

    public CallServiceV2(final ObjectProvider<CallServiceV2> callServiceProvider) {
        this.callServiceProvider = callServiceProvider;
    }

    // 외부에서 호출
    public void external() {
        log.info("call external");
        final CallServiceV2 callServiceV2 = callServiceProvider.getObject();
        callServiceV2.internal(); // 외부 메서드 호출
    }

    public void internal() {
        log.info("call internal");
    }
}
```

- 위와 같이 실행해도 동일하게 동작한다. `ApplicationContext`에서 직접 꺼내는 것보다 훨씬 나아졌다.
- `ApplicationContext` 는 너무 많은 기능을 제공한다.
- `ObjectProvider`는 **객체를 스프링 컨테이너에서 조회하는 것을 스프링 빈 생성 시점이 아니라 실제 객체를 사용하는 시점으로 지연할 수 있다.**
- `callServiceProvider.getObject()` 를 호출하는 시점에 스프링 컨테이너에서 빈을 조회한다. 여기서는 자기 자신을 주입 받는 것이 아니기 때문에 순환 사이클이 발생하지 않는다.

### 대안 3 : 구조 변경

- 앞선 방법들은 자기 자신을 주입하거나 또는 `Provider` 를 사용해야 하는 것 처럼 조금 어색한 모습을 만들었다.
- 가장 나은 대안은 내부 호출이 발생하지 않도록 구조를 변경하는 것이다.
- 실제 이 방법을 가장 권장한다

```java
@Slf4j
@Component
@RequiredArgsConstructor
public class CallServiceV3 { // 구조를 변경

    private final InternalService internalService;

    public void external() {
        log.info("call external");
        internalService.internal();
    }
}
```

```java
@Slf4j
@Component
public class InternalService {
    public void internal() {
        log.info("call internal");
    }
}
```

> Test

```java
@Import(CallLogAspect.class)
@SpringBootTest
class CallServiceV3Test {
    @Autowired
    CallServiceV3 callServiceV3;

    @Test
    void external() {
        callServiceV3.external();
    }
}
```

> 실행 결과 및 분석

```log
2022-05-24 03:44:27.460  INFO 65371 --- [    Test worker] h.aop.internalcall.aop.CallLogAspect     : aop=void hello.aop.internalcall.CallServiceV3.external()
2022-05-24 03:44:27.471  INFO 65371 --- [    Test worker] hello.aop.internalcall.CallServiceV3     : call external
2022-05-24 03:44:27.471  INFO 65371 --- [    Test worker] h.aop.internalcall.aop.CallLogAspect     : aop=void hello.aop.internalcall.InternalService.internal()
2022-05-24 03:44:27.475  INFO 65371 --- [    Test worker] hello.aop.internalcall.InternalService   : call internal
```

![](/images/2022-05-24-03-45-08.png)

- 내부 호출 자체가 사라지고, `callService -> internalService`를 호출하는 구조로 변경되었다. 덕분에 자연스럽게 AOP가 적용된다.
- 여기서 구조를 변경한다는 것은 이렇게 단순하게 분리하는 것 뿐만 아니라 다양한 방법들이 있을 수 있다.
- 예를 들어서 다음과 같이 클라이언트에서 둘다 호출하는 것이다.
  - `클라이언트 -> external()`
  - `클라이언트 -> internal()`
- 물론 이 경우 `external()` 에서 `internal()` 을 내부 호출하지 않도록 코드를 변경해야 한다. 그리고 클라이언트 `external()`, `internal()`을 모두 호출하도록 구조를 변경하면 된다. (물론 가능한 경우에 한해서)

> 참고

- AOP는 주로 트랜잭션 적용이나 주요 컴포넌트의 로그 출력 기능에 사용된다.
- 쉽게 이야기해서 인터페이스에 메서드가 나올 정도의 규모에 AOP를 적용하는 것이 적당하다.
- 더 풀어서 이야기하면 AOP는 public 메서드에만 적용한다. private 메서드처럼 작은 단위에는 AOP를 적용하지 않는다.
- AOP 적용을 위해 private 메서드를 외부 클래스로 변경하고 public 으로 변경하는 일은 거의 없다.
- 그러나 위 예제와 같이 public 메서드에서 public 메서드를 내부 호출하는 경우에는 문제가 발생한다.
- AOP가 잘 적용되지 않으면 내부 호출을 의심해보자.

## 프록시 기술과 한계

### 타입 캐스팅

### 의존 관계 주입

### CGLIB

### 스프링의 해결책