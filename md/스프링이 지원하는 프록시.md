- [스프링이 지원하는 프록시](#스프링이-지원하는-프록시)
  - [프록시 팩토리 - 소개](#프록시-팩토리---소개)
  - [프록시 팩토리 - 예제 코드](#프록시-팩토리---예제-코드)
  - [프록시 팩토리 - 예제 코드 2](#프록시-팩토리---예제-코드-2)
  - [포인트컷, 어드바이스, 어드바이저 - 소개](#포인트컷-어드바이스-어드바이저---소개)


---

# 스프링이 지원하는 프록시

## 프록시 팩토리 - 소개

앞서 사용했던 동적 프록시의 단점을 살펴보자.

**문제점**

- 인터페이스가 있는 경우 JDK 동적 프록시를 적용하고, 그렇지 않은 경우는 CGLIB를 적용하려면 어떻게 해야 할까?
- 두 기술을 함께 사용할 때 부가기능을 제공하기 위해 JDK 동적 프록시가 제공하는 InvocationHandler 와 CGLIB가 제공하는 MethodInterceptor 를 각각 중복으로 만들어서 관리해야 할까?
- 특정 조건에 맞을 때 프록시 로직을 적용하는 기능도 공통으로 제공되었으면?

**Q: 인터페이스가 있는 경우 JDK 동적 프록시를 적용하고, 그렇지 않은 경우는 CGLIB를 적용하려면 어떻게 해야 할까?**

- 스프링은 유사한 구체적인 기술들이 있을 때, 그것들을 통합해서 일관성 있게 접근할 수 있고, 더욱 편리하게 사용할 수 있는 추상화된 기술을 제공한다.
- 스프링은 동적 프록시를 통합해서 편리하게 만들어주는 **ProxyFactory**라는 기능을 제공한다.
- 이전에는 상황에 따라 JDK 동적 프록시를 사용하거나, CGLIB를 사용해야 했다면, 이제는 이 프록시 팩토리 하나로 편리하게 동적 프록시를 생성할 수 있다.
- 프록시 팩토리는 인터페이스가 있으면 JDK 동적 프록시를 사용하고, 구체 클래스만 있다면 CGLIB를 사용한다. 그리고 이 설정을 변경할 수도 있다. (예를 들어, 무조건 CGLIB만 사용하게 한다와 같이..)

![](/images/2022-05-04-17-42-28.png)

- 프록시 팩토리한테 요청하는 겁니다.
  - **"프록시 생성해주세요"** -> "인터페이스가 있네?" -> JDK 동적 Proxy로 만들어서 반환(InvocationHandler 사용)
  - **"프록시 생성해주세요"** -> "인터페이스가 없네?" -> CGLIB로 만들어서 반환(MethodInterceptor 사용)

**Q. 두 기술을 함께 사용할 때 부가기능을 제공하기 위해 JDK 동적 프록시가 제공하는 InvocationHandler 와 CGLIB가 제공하는 MethodInterceptor 를 각각 중복으로 만들어서 관리해야 할까?**

- 스프링은 이 문제를 해결하기 위해 부가기능을 적용할 때 `Advice` 라는 새로운 개념을 도입했다.
- 개발자는 `InvocationHandler`나 `MethodInterceptor`를 신경쓰지 않고, `Advice`만 만들면 된다.
- 결과적으로 `InvocationHandler`나 `MethodInterceptor`는 `Advice`를 호출하게 된다.
- 프록시 팩토리를 사용하면 `Advice`를 호출하는 전용 `InvocationHandler`, `MethodInterceptor`를 내부에서 사용한다.

![](/images/2022-05-05-00-44-22.png)

**Q: 특정 조건에 맞을 때 프록시 로직을 적용하는 기능도 공통으로 제공되었으면?**

- 앞서 특정 메서드 이름의 조건에 맞을 때만 프록시 부가 기능이 적용되는 코드를 직접 만들었다. 스프링은 `Pointcut` 이라는 개념을 도입해서 이 문제를 일관성 있게 해결한다.


## 프록시 팩토리 - 예제 코드

**Advice 만들기**

- `Advice`는 프록시에 적용하는 부가 기능 로직
- JDK 동적 프록시가 제공하는 `InvocationHandler`와 `CGLIB`가 제공하는 `MethodInterceptor` 개념과 유사함. 둘을 개념적으로 추상화한 것.
- 프록시 팩토리를 사용하면 위의 2개 대신에 `Advice`를 사용하면 된다.
- `Advice`를 만드는 방법은 여러가지가 있지만, 기본적인 방법은 다음 인터페이스를 구현하면 된다.

> MethodInterceptor - 스프링이 제공하는 코드

```java
package org.aopalliance.intercept;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

/**
 * Intercepts calls on an interface on its way to the target. These
 * are nested "on top" of the target.
 *
 * <p>The user should implement the {@link #invoke(MethodInvocation)}
 * method to modify the original behavior. E.g. the following class
 * implements a tracing interceptor (traces all the calls on the
 * intercepted method(s)):
 *
 * <pre class=code>
 * class TracingInterceptor implements MethodInterceptor {
 *   Object invoke(MethodInvocation i) throws Throwable {
 *     System.out.println("method "+i.getMethod()+" is called on "+
 *                        i.getThis()+" with args "+i.getArguments());
 *     Object ret=i.proceed();
 *     System.out.println("method "+i.getMethod()+" returns "+ret);
 *     return ret;
 *   }
 * }
 * </pre>
 *
 * @author Rod Johnson
 */
@FunctionalInterface
public interface MethodInterceptor extends Interceptor {

	/**
	 * Implement this method to perform extra treatments before and
	 * after the invocation. Polite implementations would certainly
	 * like to invoke {@link Joinpoint#proceed()}.
	 * @param invocation the method invocation joinpoint
	 * @return the result of the call to {@link Joinpoint#proceed()};
	 * might be intercepted by the interceptor
	 * @throws Throwable if the interceptors or the target object
	 * throws an exception
	 */
	@Nullable
	Object invoke(@Nonnull MethodInvocation invocation) throws Throwable;

}
```

- 위 인터페이스는 `Interceptor`를 받고 있고, `Interceptor`는 `Advice`를 받고 있다.

```java
package org.aopalliance.intercept;

import org.aopalliance.aop.Advice;

/**
 * This interface represents a generic interceptor.
 *
 * <p>A generic interceptor can intercept runtime events that occur
 * within a base program. Those events are materialized by (reified
 * in) joinpoints. Runtime joinpoints can be invocations, field
 * access, exceptions...
 *
 * <p>This interface is not used directly. Use the sub-interfaces
 * to intercept specific events. For instance, the following class
 * implements some specific interceptors in order to implement a
 * debugger:
 *
 * <pre class=code>
 * class DebuggingInterceptor implements MethodInterceptor,
 *     ConstructorInterceptor {
 *
 *   Object invoke(MethodInvocation i) throws Throwable {
 *     debug(i.getMethod(), i.getThis(), i.getArgs());
 *     return i.proceed();
 *   }
 *
 *   Object construct(ConstructorInvocation i) throws Throwable {
 *     debug(i.getConstructor(), i.getThis(), i.getArgs());
 *     return i.proceed();
 *   }
 *
 *   void debug(AccessibleObject ao, Object this, Object value) {
 *     ...
 *   }
 * }
 * </pre>
 *
 * @author Rod Johnson
 * @see Joinpoint
 */
public interface Interceptor extends Advice {

}
```

- `MethodInvocation invocation`
  - 내부에는 다음 메서드를 호출하는 방법, 현재 프록시 객체 인스턴스, args, 메서드 정보 등이 포함되어 있다.
  - 기존에 파라미터로 제공되는 부분들이 이 안으로 모두 들어갔다고 생각하면 된다.
- `CGLIB`의 `MethodInterceptor`와 이름이 같으므로 **패키지 이름에 주의**하자.
  - 참고로 여기서 사용하는 `org.aopalliance.intercept` 패키지는 스프링의 AOP 모듈(spring-top) 안에 있다.
- `MethodInterceptor`는 `Interceptor`를 상속하고, `Interceptor`는 `Advice` 인터페이스를 상속한다.

이제 실제 `Advice`를 만들어본다.

```java
import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class TimeAdvice implements MethodInterceptor {
    // 이제 타겟을 넣어주지 않아도 됩니다. 프록시 팩토리에서 만들 때 타겟을 이미 만들기 때문입니다.

    @Override
    public Object invoke(final MethodInvocation invocation) throws Throwable {
        log.info("TimeProxy 실행");
        final long startTime = System.currentTimeMillis();
        final long endTime = System.currentTimeMillis();

        // invocation.proceed()에서 타겟을 찾아서, 매개변수(args)도 넘겨주고 실행을 하게 됩니다.
        final Object result = invocation.proceed();

        final long resultTime = endTime - startTime;
        log.info("TimeProxy 종료. resultTime = {}", resultTime);
        return result;
    }
}
```

- `TimeAdvice`는 앞서 설명한 `MethodInterceptor` 인터페이스를 구현한다. **패키지 이름에 주의하자**
- `Object result = invocation.proceed()`
  - `invocation.proceed()`를 호출하면, `target`클래스를 호출하고 그 결과를 받습니다.
  - 그런데 기존에 보았던 코드들과 다르게, `target`클래스의 정보가 보이지 않습니다.
  - `target` 클래스 정보는 `MethodInvocation invocation` 안에 모두 포함되어 있습니다.
  - 그 이유는 바로 다음에서 확인할 수 있는데, 프록시 팩토리로 프록시를 생성하는 단계에서 이미 `target`정보를 파라미터로 전달받기 때문입니다.

> 테스트 코드

```java
@DisplayName("인터페이스가 있으면 JDK 동적 프록시 사용")
@Test
void interfaceProxy() {
    final ServiceInterface target = new ServiceInterfaceImpl();
    final ProxyFactory proxyFactory = new ProxyFactory(target);
    proxyFactory.addAdvice(new TimeAdvice());
    final ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();
    log.info("targetClass={}", target.getClass());
    log.info("proxyClass={}", proxy.getClass());

    proxy.save();

    assertThat(AopUtils.isAopProxy(proxy)).isTrue(); // ProxyFactory를 통해서 만들었을 때만 이것을 사용할 수 있다.
    assertThat(AopUtils.isJdkDynamicProxy(proxy)).isTrue();
    assertThat(AopUtils.isCglibProxy(proxy)).isFalse();
}
```

- 실행 결과

```log
04:13:53.157 [main] INFO hello.proxy.proxyfactory.ProxyFactoryTest - targetClass=class hello.proxy.common.service.ServiceInterfaceImpl
04:13:53.159 [main] INFO hello.proxy.proxyfactory.ProxyFactoryTest - proxyClass=class com.sun.proxy.$Proxy10
04:13:53.163 [main] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 실행
04:13:53.163 [main] INFO hello.proxy.common.service.ServiceInterfaceImpl - save 호출
04:13:53.164 [main] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 종료. resultTime = 0
```

- **`new ProxyFactory(target)`**
  - 프록시 팩토리를 생성할 때 생성자에 프록시의 호출 대상을 **함께** 넘겨준다.
  - 프록시 팩토리는 이 인스턴스 정보를 기반으로 프록시를 만들어낸다.
  - 만약 이 인스턴스에 인터페이스가 있다면, JDK 동적프록시를 기본으로 사용하고, 인터페이스가 없고 구체 클래스만 있다면 CGLIB를 통해서 동적 프록시를 생성한다.
  - 여기서는 `target`이 `new ServiceInterfaceImpl()`의 인스턴스이기 때문에 `ServiceInterface` 가 있다.
  - 따라서 이 인터페이스를 기반으로 JDK 동적 프록시를 생성한다.
- **`proxyFactory.addAdvice(new TimeAdvice())`**
  - 프록시 팩토리를 통해서 만든 프록시가 사용할 부가 기능 로직을 설정
  - JDK 동적 프록시가 제공하는 `InvocationHandler`와 CGLIB가 제공하는 `MethodInterceptor` 의 개념과 유사하다.
  - 이렇게 프록시가 제공하는 부가 기능 로직을 어드바이스(`Advice`)라고 한다.
- **`proxyFactory.getProxy()`**
  - 프록시 객체를 생성하고, 그 결과를 받는다.

- 결과로 `com.sun.proxy.$Proxy10`이 붙은 것을 보면, JDK 동적 프록시가 적용된 것을 확인할 수 있다.

> **프록시 팩토리를 통한 프록시 적용 확인**

**AopUtils.isAopProxy(proxy)** : 프록시 팩토리를 통해서 프록시가 생성되면, JDK 동적 프록시나, CGLIB 모두 참이다.

**AopUtils.isJdkDynamicProxy(proxy)** : 프록시 팩토리를 통해서 프록시가 생성이 되고, JDK 동적 프록시인 경우 참

**AopUtils.isCglibProxy(proxy)** : 프록시 팩토리를 통해서 프록시가 생성되고, CGLIB 동적 프록시인 경우 참


## 프록시 팩토리 - 예제 코드 2

- 이제 CGLIB를 테스트해보자.

```java
@DisplayName("구체 클래스만 있으면 CGLIB 사용")
@Test
void concreteProxy() {
    final ConcreteService target = new ConcreteService();
    final ProxyFactory proxyFactory = new ProxyFactory(target);
    proxyFactory.addAdvice(new TimeAdvice());
    final ConcreteService proxy = (ConcreteService) proxyFactory.getProxy();
    log.info("targetClass={}", target.getClass());
    log.info("proxyClass={}", proxy.getClass());

    proxy.call();

    assertThat(AopUtils.isAopProxy(proxy)).isTrue(); // ProxyFactory를 통해서 만들었을 때만 이것을 사용할 수 있다.
    assertThat(AopUtils.isJdkDynamicProxy(proxy)).isFalse();
    assertThat(AopUtils.isCglibProxy(proxy)).isTrue();
}
```

- 실행 결과

```log
04:26:02.559 [main] INFO hello.proxy.proxyfactory.ProxyFactoryTest - targetClass=class hello.proxy.common.service.ConcreteService
04:26:02.562 [main] INFO hello.proxy.proxyfactory.ProxyFactoryTest - proxyClass=class hello.proxy.common.service.ConcreteService$$EnhancerBySpringCGLIB$$44199858
04:26:02.564 [main] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 실행
04:26:02.574 [main] INFO hello.proxy.common.service.ConcreteService - ConcreteService 호출
04:26:02.574 [main] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 종료. resultTime = 0
```

- `proxyClass=class hello.proxy.common.service.ConcreteService$$EnhancerBySpringCGLIB$$44199858` 를 통해 CGLIB 프록시가 적용된 것도 확인할 수 있다.

> Interface가 있어도, proxy를 CGLIB로 만들고 싶다면?

- 인터페이스가 있지만, CGLIB를 사용해서 인터페이스가 아닌 클래스 기반으로 동적 프록시를 만드는 방법을 알아보자.
- 프록시 팩토리는 `proxyTargetClass`라는 옵션을 제공하는데, 이 옵션에 `true` 값을 넣으면, 인터페이스가 있어도 강제로 CGLIB를 사용한다.
- 그리고 인터페이스가 아닌 클래스 기반의 프록시를 만들어준다.
- `proxyFactory.setProxyTargetClass(true)`로 설정하자.


```java
@DisplayName("ProxyTargetClass 옵션을 사용하면, 인터페이스가 있어도 CGLIB를 사용하고, 클래스 기반 프록시 사용한다")
@Test
void proxyTargetClass() {
    final ServiceInterface target = new ServiceInterfaceImpl();
    final ProxyFactory proxyFactory = new ProxyFactory(target);
    proxyFactory.setProxyTargetClass(true); // 프록시를 만드는데, targetClass 기반으로 프록시를 만들 것이다 => CGLIB 기반
    proxyFactory.addAdvice(new TimeAdvice());
    final ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();
    log.info("targetClass={}", target.getClass());
    log.info("proxyClass={}", proxy.getClass());

    proxy.save();

    assertThat(AopUtils.isAopProxy(proxy)).isTrue();
    assertThat(AopUtils.isJdkDynamicProxy(proxy)).isFalse();
    assertThat(AopUtils.isCglibProxy(proxy)).isTrue();
}
```

- 실행 결과

```log
04:29:12.022 [main] INFO hello.proxy.proxyfactory.ProxyFactoryTest - targetClass=class hello.proxy.common.service.ServiceInterfaceImpl
04:29:12.024 [main] INFO hello.proxy.proxyfactory.ProxyFactoryTest - proxyClass=class hello.proxy.common.service.ServiceInterfaceImpl$$EnhancerBySpringCGLIB$$bbbd9931
04:29:12.026 [main] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 실행
04:29:12.034 [main] INFO hello.proxy.common.service.ServiceInterfaceImpl - save 호출
04:29:12.034 [main] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 종료. resultTime = 0
```

- `class hello.proxy.common.service.ServiceInterfaceImpl$$EnhancerBySpringCGLIB$$bbbd9931` 를 보면, 인터페이스가 있음에도, CGLIB proxy가 생성된 것을 확인할 수 있다.

**프록시 팩토리의 기술 선택 방법**

- 대상에 인터페이스가 있다면 : JDK 동적 프록시, 인터페이스 기반 프록시
- 대상에 인터페이스가 없으면 : CGLIB, 구체 클래스 기반 프록시
- `proxyTargetClass=true`: CGLIB, 구체 클래스 기반 프록시, 인터페이스 여부와 상관 없음

> **정리**

- 프록시 팩토리의 서비스 추상화 덕분에 구체적인 CGLIB, JDK 동적 프록시 기술에 의존하지 않고, 매우 편리하게 동적 프록시를 생성할 수 있다.
- 프록시의 부가 기능 로직도 특정 기술에 종속적이지 않게 `Advice` 하나로 편리하게 사용할 수 있었다.
- 이것은 프록시 팩토리가 내부에서 JDK 동적 프록시인 경우 `InvocationHandler`가 `Advice`를 호출하도록 개발해두고, CGLIB인 경우 `MethodInterceptor`가 `Advice` 를 호출하도록 기능을 개발해두었기 때문이다.

***참고***
- 스프링 부트(2.0 이상)는 AOP를 적용할 때 기본적으로 `proxyTargetClass=true`로 설정해서 사용한다.
- 따라서 인터페이스가 있어도 항상 CGLIB를 사용해서 구체 클래스를 기반으로 프록시를 생성한다.

## 포인트컷, 어드바이스, 어드바이저 - 소개

> **포인트컷(Pointcut)**

- 어디에 부가 기능을 적용할지, 어디에 부가 기능을 적용하지 않을지 판단하는 **필터링** 로직이다.
- 주로 클래스와 메서드 이름으로 필터링한다.
- 이름 그대로 어떤 포인트(Point)에 기능을 적용할지, 하지 않을지 잘라서(cut) 구분하는 것이다.

> **어드바이스(Advice)**

- 이전에 본 것처럼, **프록시가 호출하는 부가 기능**이다.
- 단순하게 프록시 로직이라고 생각하면 편하다.

> **어드바이저(Advisor)**

- 단순하게 하나의 포인트 컷과 하나의 어드바이스를 가지고 있는 것이다.
- 쉽게 이야기하여 **`Pointcut 1 + Advice 1`** 이다.

***정리하면, 부가 기능 로직을 적용해야 하는데, 포인트 컷으로 `어디에?` 적용할 지 선택하고, 어드바이스로 `어떤 로직`을 적용할지 선택하는 것이다. 그리고 `어디에?` `어떤로직?`을 모두 알고 있는 것이 어드바이저이다.***

> 쉽게 기억하기

- 조언(Advice)을 어디(Pointcut)에 할 것인가?
- 조언자(Advisor)는 어디(Pointcut)에 조언(Advice)을 해야할 지 알고 있다.

> 역할과 책임

- 이렇게 구분한 이유는 역할과 책임을 명확하게 분리한 것이다.
- **포인트컷**은 대상 여부를 확인하는 **필터 역할**만 담당한다.
- **어드바이스**는 깔끔하게 **부가 기능 로직**만 담당한다.
- 둘을 합치면 어드바이저가 된다. 스프링의 **어드바이저는 하나의 포인트컷 + 하나의 어드바이스로 구성**된다.

> 참고

해당 단어들에 대한 정의는 지금은 문맥상 이해를 돕기 위해 프록시에 맞추어서 설명하지만, 이후 AOP 부분에서 다시 한 번 AOP에 맞추어 정리할 것이다.

![](/images/2022-05-05-04-44-55.png)
