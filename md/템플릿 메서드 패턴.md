- [템플릿 메서드 패턴 - 시작](#템플릿-메서드-패턴---시작)
- [템플릿 메서드 패턴 - 예제 1](#템플릿-메서드-패턴---예제-1)

---
## 템플릿 메서드 패턴 - 시작

- 로그 추적기 도입 전의 코드와 로그 추적기 도입 후의 코드를 비교해보자

> **로그 추적기 도입 전**

```java
@RestController // @Controller + @ResponseBody
@RequiredArgsConstructor
public class OrderControllerV0 {

    private final OrderServiceV0 orderService;

    @GetMapping("/v0/request")
    public String request(String itemId) {
        orderService.orderItem(itemId);
        return "ok";
    }
}
```

> **로그 추적기 도입 후**

```java
@RestController // @Controller + @ResponseBody
@RequiredArgsConstructor
public class OrderControllerV3 {

    private final OrderServiceV3 orderService;
    private final LogTrace trace;

    @GetMapping("/v3/request")
    public String request(String itemId) {

        final TraceStatus status = trace.begin("OrderControllerV3.request()");
        try {
            orderService.orderItem(itemId);
            trace.end(status);
            return "ok";
        } catch (Exception e) {
            trace.exception(status, e);
            throw e; // 예외를 꼭 다시 던져주어야 한다.
        }
    }
}
```

- 로그 추적기를 붙이게 되면서, 핵심 기능보다 부가기능(로그를 출력) 코드가 더 많고 복잡하다.


> **핵심기능 vs 부가기능**

- 핵심기능
  - 해당 객체가 제공하는 고유의 기능
  - 예를 들어, 서비스에서는 주문 데이터를 저장하기 위해 리포지토리를 호출하는 orderRepository.save(itemId) 가 핵심 기능이다.

- 부가기능
  - 핵심 기능을 보조하기 위해 제공되는 기능.
  - 예를 들어, 로그 추적 로직, 트랜잭션 기능 등
  - 이런 부가 기능은 단독으로 사용되지는 않고 핵심 로직과 함께 사용된다.
  - 즉, 핵심 기능을 보조하기 위해 존재하는 것이다.

로그 추적기를 붙이기 전에는 핵심 기능만 있었으나, 로그 추적기를 붙이니 핵심 기능과 부가 기능이 함께 섞여있다. 게다가 배보다 배꼽이 더 커진 상황.

만약 클랙스가 수백개가 된다면, 어떻게 처리하겠는가?

다시 한 번 로그 추적기 도입된 코드를 확인해보자.
여기에 다음과 같은 공통 패턴이 있음을 확인할 수 있다.

```java
final TraceStatus status = trace.begin("message");
try {
    // 여기에 핵심 기능을 호출한다.
    trace.end(status);
    return "ok";
} catch (Exception e) {
    trace.exception(status, e);
    throw e;
}
```

- 부가 기능과 관련된 코드가 중복이니, 중복을 별도의 메서드로 뽑아내면 될 것 같다.
- 그런데, try~catch는 물론이고, 핵심 기능 부분이 중간에 있어서 단순하게 메서드로 추출하는 것이 어렵다.

> **변하는 것과 변하지 않는 것을 분리하자**

- 좋은 설계란, 변하는 것과 변하지 않는 것을 분리하는 것이다.
- 여기서 핵심 기능 부분은 변하고, 로그 추적기 쪽은 변하지 않는 부분이다.
- 이 둘을 분리해서 모듈화해야한다.


**템플릿 메서드 패턴(Template Method Pattern)은 이러한 문제를 해결하는 디자인 패턴이다.**

## 템플릿 메서드 패턴 - 예제 1

```java
@Slf4j
public class TemplateMethodTest {

    @Test
    void templateMethodV0() {
        logic1();
        logic2();
    }

    private void logic1() {
        final long startTime = System.currentTimeMillis();
        // 비즈니스 로직 실행
        log.info("비즈니스 로직1 실행");
        // 비즈니스 로직 종료
        final long endTime = System.currentTimeMillis();
        final long resultTime = endTime - startTime;
        log.info("resultTime = {}", resultTime);
    }

    private void logic2() {
        final long startTime = System.currentTimeMillis();
        // 비즈니스 로직 실행
        log.info("비즈니스 로직2 실행");
        // 비즈니스 로직 종료
        final long endTime = System.currentTimeMillis();
        final long resultTime = endTime - startTime;
        log.info("resultTime = {}", resultTime);
    }
}
```

- logic1()과 logic2()는 시간을 측정하는 부분과 비즈니스 로직을 실행하는 부분이 함께 존재한다.
  - 변하는 부분 : 비즈니스 로직
  - 변하지 않는 부분 : 시간 측정
- 이제 템플릿 메서드 패턴을 사용해서 변하지는 부분과 변하지 않는 부분을 분리해보자.
