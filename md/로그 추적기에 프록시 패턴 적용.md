- [로그 추적기에 프록시 패턴(데코레이터 패턴)을 적용해보자](#로그-추적기에-프록시-패턴데코레이터-패턴을-적용해보자)
  - [인터페이스 기반 프록시 - 적용](#인터페이스-기반-프록시---적용)
  - [구체 클래스 기반 프록시](#구체-클래스-기반-프록시)
    - [예제 1](#예제-1)

---

# 로그 추적기에 프록시 패턴(데코레이터 패턴)을 적용해보자

## 인터페이스 기반 프록시 - 적용

- 인터페이스와 구현체가 있는 V1 app에 지금까지 학습한 프록시를 도입해서 LogTrace를 사용해보자.
- **프록시를 사용하면 기존 코드를 전혀 수정하지 않고, 로그 추적 기능을 도입할 수 있다.**

> 기존

![](/images/2022-05-03-00-43-31.png)

> 로그 추적용 프록시를 도입한다면?

![](/images/2022-05-03-00-43-50.png)
![](/images/2022-05-03-00-45-01.png)


- Controller Proxy

```java
@RequiredArgsConstructor
public class OrderControllerInterfaceProxy implements OrderControllerV1 {

    private final OrderControllerV1 target;
    private final LogTrace logTrace;

    @Override
    public String request(final String itemId) {
        TraceStatus status = null;
        try {
            status = logTrace.begin("OrderController.request()");
            // target 호출
            final String request = target.request(itemId);
            logTrace.end(status);
            return request;
        } catch (Exception e) {
            logTrace.exception(status, e);
            throw e;
        }
    }

    /**
     * 아무런 로그를 찍으면 안되므로 다음과 같이 단순하게 처리하면 된다.
     */
    @Override
    public String noLog() {
//        TraceStatus status = null;
//        try {
//            status = logTrace.begin("OrderController.noLog()");
        // target 호출
        final String result = target.noLog();
//            logTrace.end(status);
        return result;
//        } catch (Exception e) {
//            logTrace.exception(status, e);
//            throw e;
//        }
    }
}
```

- Service Proxy

```java
@RequiredArgsConstructor
public class OrderServiceInterfaceProxy implements OrderServiceV1 {

    private final OrderServiceV1 target;
    private final LogTrace logTrace;

    @Override
    public void orderItem(final String itemId) {
        TraceStatus status = null;
        try {
            status = logTrace.begin("OrderService.orderItem()");
            // target 호출
            target.orderItem(itemId);
            logTrace.end(status);
        } catch (Exception e) {
            logTrace.exception(status, e);
            throw e;
        }
    }
}
```

- Repository Proxy

```java
@RequiredArgsConstructor
public class OrderRepositoryInterfaceProxy implements OrderRepositoryV1 {

    private final OrderRepositoryV1 target; // 실제 호출할 대상, 다른 프록시가 낀다면 해당 프록시가 될 수도 있음
    private final LogTrace logTrace;

    @Override
    public void save(final String itemId) {
        TraceStatus status = null;
        try {
            status = logTrace.begin("OrderRepository.request()");
            // target 호출
            target.save(itemId);
            logTrace.end(status);
        } catch (Exception e) {
            logTrace.exception(status, e);
            throw e;
        }
    }
}
```

- **Interface Proxy Config**

중요한 것은, ControllerImpl 에서 Service`Proxy`를 호출해야 한다는 것이다. 같은 원리로 ServiceImpl에서 Repository`Proxy`를 호출해야 한다.

```java
@Configuration
public class InterfaceProxyConfig {

    @Bean
    public OrderControllerV1 orderController(LogTrace logTrace) {
        final OrderControllerV1Impl controllerImpl = new OrderControllerV1Impl(orderService(logTrace)); // 서비스 프록시를 호출해야한다. 그래야 서비스 프록시에서 로그를 찍는다.
        return new OrderControllerInterfaceProxy(controllerImpl, logTrace);
    }

    @Bean
    public OrderServiceV1 orderService(LogTrace logTrace) {
        final OrderServiceV1Impl serviceImpl = new OrderServiceV1Impl(orderRepository(logTrace));
        return new OrderServiceInterfaceProxy(serviceImpl, logTrace);
    }

    @Bean
    public OrderRepositoryV1 orderRepository(LogTrace logTrace) {
        final OrderRepositoryV1Impl repositoryImpl = new OrderRepositoryV1Impl();
        return new OrderRepositoryInterfaceProxy(repositoryImpl, logTrace);
    }
}
```

- `LogTrace`가 아직 스프링 빈으로 등록되어 있지 않은데, 이후 추가할 예정이다.


**V1 프록시 런타임 객체 의존관계 설정**

- 이제 프록시의 런타임 객체 의존 관계를 설정하면 된다.
- 기존에는 스프링 빈이 `orderControllerV1Impl`, `orderServiceV1Impl` 같은 실제 객체를 반환했다.
- 하지만 이제는 프록시를 사용해야 한다.
- 따라서 프록시를 생성하고, **프록시를 실제 스프링 빈 대신 등록한다.** **실제 객체는 스프링 빈으로 등록하지 않는다.**
- 프록시 내부에 실제 객체를 참조하고 있다.
  - 예를 들어, `OrderServiceInterfaceProxy`는 내부에 실제 대상 객체인 `OrderServiceV1Impl` 을 가지고 있다.
- 정리하면 다음과 같은 의존관계이다.
  - proxy -> target
  - orderServiceIntercaeProxy -> orderServiceV1Impl

- 스프링 빈으로 실제 객체 대신에 프록시 객체를 등록했기 때문에 앞으로 스프링 빈 주입을 받으면, **실제 객체 대신에 프록시 객체가 주입**된다.

- 실제 객체가 스프링 빈으로 등록되지 않는다고 해서 사라지는 것은 아니다.
- **프록시 객체가 실제 객체를 참조하기 때문에 프록시를 통해서 실제 객체를 호출할 수 있다.** **쉽게 이야기해서 프록시 객체 안에 실제 객체가 있는 것**이다.

![](/images/2022-05-03-01-12-04.png)

- 이제 실제 객체는 스프링 컨테이너와 상관이 없다. 실제 객체는 프록시 객체를 통해서 참조될 뿐이다.
- 프록시 객체는 스프링 컨테이너가 관리하고, 자바 힙 메모리에도 올라간다. 반면, 실제 객체는 자바 힙 메모리에는 올라가지만, 스프링 컨테이너가 관리하지는 않는다.

![](/images/2022-05-03-01-14-53.png)


- Application main

```java
@Import(InterfaceProxyConfig.class)
@SpringBootApplication(scanBasePackages = "hello.proxy.app") //주의
public class ProxyApplication {

	public static void main(String[] args) {
		SpringApplication.run(ProxyApplication.class, args);
	}

	@Bean
	public LogTrace logTrace(){
		return new ThreadLocalLogTrace();
	}
}
```

- 이제, v1에서도 로그 추적 기능이 잘 동작함을 확인해볼 수 있다.

```
http://localhost:8080/v1/request?itemId=DolphaGo
```

```log
2022-05-03 01:16:29.719  INFO 94864 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace   : [bd9091dc] OrderController.request()
2022-05-03 01:16:29.721  INFO 94864 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace   : [bd9091dc] |-->OrderService.orderItem()
2022-05-03 01:16:29.721  INFO 94864 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace   : [bd9091dc] |   |-->OrderRepository.request()
2022-05-03 01:16:30.722  INFO 94864 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace   : [bd9091dc] |   |<--OrderRepository.request() time=1001ms
2022-05-03 01:16:30.722  INFO 94864 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace   : [bd9091dc] |<--OrderService.orderItem() time=1001ms
2022-05-03 01:16:30.722  INFO 94864 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace   : [bd9091dc] OrderController.request() time=1003ms
```

> 정리

- 원본 코드를 전혀 수정하지 않고, 로그 추적기를 도입할 수 있었다.
- 사실 자바의 다형성 덕분에 인터페이스든 클래스든 모두 프록시를 적용할 수 있다. 그건 V2, V3에서 알아보도록 하자.

## 구체 클래스 기반 프록시

인터페이스가 없어도 프록시를 적용할 수 있을까?
예제부터 알아보도록 하자.

### 예제 1

```java
@Slf4j
public class ConcreteLogic {

    public String operation(){
        log.info("ConcreteLogic 실행");
        return "data";
    }
}
```

![](/images/2022-05-03-01-23-17.png)

- Concrete Client

```java
public class ConcreteClient {
    private ConcreteLogic concreteLogic;

    public ConcreteClient(final ConcreteLogic concreteLogic) {
        this.concreteLogic = concreteLogic;
    }

    public void execute() {
        concreteLogic.operation();
    }
}
```

- Test

```java
@DisplayName("프록시 적용 전")
@Test
void noProxy() {
    final ConcreteLogic concreteLogic = new ConcreteLogic();
    final ConcreteClient client = new ConcreteClient(concreteLogic);
    client.execute();
}
```