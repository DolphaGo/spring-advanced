- [로그 추적기에 프록시 패턴(데코레이터 패턴)을 적용해보자](#로그-추적기에-프록시-패턴데코레이터-패턴을-적용해보자)
  - [인터페이스 기반 프록시 - 적용](#인터페이스-기반-프록시---적용)
  - [구체 클래스 기반 프록시](#구체-클래스-기반-프록시)
    - [예제 1](#예제-1)
    - [예제 2](#예제-2)

---

# 로그 추적기에 프록시 패턴(데코레이터 패턴)을 적용해보자

## 인터페이스 기반 프록시 - 적용

- 인터페이스와 구현체가 있는 V1 app에 지금까지 학습한 프록시를 도입해서 LogTrace를 사용해보자.
- **프록시를 사용하면 기존 코드를 전혀 수정하지 않고, 로그 추적 기능을 도입할 수 있다.**

> 기존

![](/images/2022-05-03-00-43-31.png)

> 로그 추적용 프록시를 도입한다면?

![](/images/2022-05-03-00-43-50.png)
![](/images/2022-05-03-00-45-01.png)


- Controller Proxy

```java
@RequiredArgsConstructor
public class OrderControllerInterfaceProxy implements OrderControllerV1 {

    private final OrderControllerV1 target;
    private final LogTrace logTrace;

    @Override
    public String request(final String itemId) {
        TraceStatus status = null;
        try {
            status = logTrace.begin("OrderController.request()");
            // target 호출
            final String request = target.request(itemId);
            logTrace.end(status);
            return request;
        } catch (Exception e) {
            logTrace.exception(status, e);
            throw e;
        }
    }

    /**
     * 아무런 로그를 찍으면 안되므로 다음과 같이 단순하게 처리하면 된다.
     */
    @Override
    public String noLog() {
//        TraceStatus status = null;
//        try {
//            status = logTrace.begin("OrderController.noLog()");
        // target 호출
        final String result = target.noLog();
//            logTrace.end(status);
        return result;
//        } catch (Exception e) {
//            logTrace.exception(status, e);
//            throw e;
//        }
    }
}
```

- Service Proxy

```java
@RequiredArgsConstructor
public class OrderServiceInterfaceProxy implements OrderServiceV1 {

    private final OrderServiceV1 target;
    private final LogTrace logTrace;

    @Override
    public void orderItem(final String itemId) {
        TraceStatus status = null;
        try {
            status = logTrace.begin("OrderService.orderItem()");
            // target 호출
            target.orderItem(itemId);
            logTrace.end(status);
        } catch (Exception e) {
            logTrace.exception(status, e);
            throw e;
        }
    }
}
```

- Repository Proxy

```java
@RequiredArgsConstructor
public class OrderRepositoryInterfaceProxy implements OrderRepositoryV1 {

    private final OrderRepositoryV1 target; // 실제 호출할 대상, 다른 프록시가 낀다면 해당 프록시가 될 수도 있음
    private final LogTrace logTrace;

    @Override
    public void save(final String itemId) {
        TraceStatus status = null;
        try {
            status = logTrace.begin("OrderRepository.request()");
            // target 호출
            target.save(itemId);
            logTrace.end(status);
        } catch (Exception e) {
            logTrace.exception(status, e);
            throw e;
        }
    }
}
```

- **Interface Proxy Config**

중요한 것은, ControllerImpl 에서 Service`Proxy`를 호출해야 한다는 것이다. 같은 원리로 ServiceImpl에서 Repository`Proxy`를 호출해야 한다.

```java
@Configuration
public class InterfaceProxyConfig {

    @Bean
    public OrderControllerV1 orderController(LogTrace logTrace) {
        final OrderControllerV1Impl controllerImpl = new OrderControllerV1Impl(orderService(logTrace)); // 서비스 프록시를 호출해야한다. 그래야 서비스 프록시에서 로그를 찍는다.
        return new OrderControllerInterfaceProxy(controllerImpl, logTrace);
    }

    @Bean
    public OrderServiceV1 orderService(LogTrace logTrace) {
        final OrderServiceV1Impl serviceImpl = new OrderServiceV1Impl(orderRepository(logTrace));
        return new OrderServiceInterfaceProxy(serviceImpl, logTrace);
    }

    @Bean
    public OrderRepositoryV1 orderRepository(LogTrace logTrace) {
        final OrderRepositoryV1Impl repositoryImpl = new OrderRepositoryV1Impl();
        return new OrderRepositoryInterfaceProxy(repositoryImpl, logTrace);
    }
}
```

- `LogTrace`가 아직 스프링 빈으로 등록되어 있지 않은데, 이후 추가할 예정이다.


**V1 프록시 런타임 객체 의존관계 설정**

- 이제 프록시의 런타임 객체 의존 관계를 설정하면 된다.
- 기존에는 스프링 빈이 `orderControllerV1Impl`, `orderServiceV1Impl` 같은 실제 객체를 반환했다.
- 하지만 이제는 프록시를 사용해야 한다.
- 따라서 프록시를 생성하고, **프록시를 실제 스프링 빈 대신 등록한다.** **실제 객체는 스프링 빈으로 등록하지 않는다.**
- 프록시 내부에 실제 객체를 참조하고 있다.
  - 예를 들어, `OrderServiceInterfaceProxy`는 내부에 실제 대상 객체인 `OrderServiceV1Impl` 을 가지고 있다.
- 정리하면 다음과 같은 의존관계이다.
  - proxy -> target
  - orderServiceIntercaeProxy -> orderServiceV1Impl

- 스프링 빈으로 실제 객체 대신에 프록시 객체를 등록했기 때문에 앞으로 스프링 빈 주입을 받으면, **실제 객체 대신에 프록시 객체가 주입**된다.

- 실제 객체가 스프링 빈으로 등록되지 않는다고 해서 사라지는 것은 아니다.
- **프록시 객체가 실제 객체를 참조하기 때문에 프록시를 통해서 실제 객체를 호출할 수 있다.** **쉽게 이야기해서 프록시 객체 안에 실제 객체가 있는 것**이다.

![](/images/2022-05-03-01-12-04.png)

- 이제 실제 객체는 스프링 컨테이너와 상관이 없다. 실제 객체는 프록시 객체를 통해서 참조될 뿐이다.
- 프록시 객체는 스프링 컨테이너가 관리하고, 자바 힙 메모리에도 올라간다. 반면, 실제 객체는 자바 힙 메모리에는 올라가지만, 스프링 컨테이너가 관리하지는 않는다.

![](/images/2022-05-03-01-14-53.png)


- Application main

```java
@Import(InterfaceProxyConfig.class)
@SpringBootApplication(scanBasePackages = "hello.proxy.app") //주의
public class ProxyApplication {

	public static void main(String[] args) {
		SpringApplication.run(ProxyApplication.class, args);
	}

	@Bean
	public LogTrace logTrace(){
		return new ThreadLocalLogTrace();
	}
}
```

- 이제, v1에서도 로그 추적 기능이 잘 동작함을 확인해볼 수 있다.

```
http://localhost:8080/v1/request?itemId=DolphaGo
```

```log
2022-05-03 01:16:29.719  INFO 94864 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace   : [bd9091dc] OrderController.request()
2022-05-03 01:16:29.721  INFO 94864 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace   : [bd9091dc] |-->OrderService.orderItem()
2022-05-03 01:16:29.721  INFO 94864 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace   : [bd9091dc] |   |-->OrderRepository.request()
2022-05-03 01:16:30.722  INFO 94864 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace   : [bd9091dc] |   |<--OrderRepository.request() time=1001ms
2022-05-03 01:16:30.722  INFO 94864 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace   : [bd9091dc] |<--OrderService.orderItem() time=1001ms
2022-05-03 01:16:30.722  INFO 94864 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace   : [bd9091dc] OrderController.request() time=1003ms
```

> 정리

- 원본 코드를 전혀 수정하지 않고, 로그 추적기를 도입할 수 있었다.
- 사실 자바의 다형성 덕분에 인터페이스든 클래스든 모두 프록시를 적용할 수 있다. 그건 V2, V3에서 알아보도록 하자.

## 구체 클래스 기반 프록시

인터페이스가 없어도 프록시를 적용할 수 있을까?
예제부터 알아보도록 하자.

### 예제 1

```java
@Slf4j
public class ConcreteLogic {

    public String operation(){
        log.info("ConcreteLogic 실행");
        return "data";
    }
}
```

![](/images/2022-05-03-01-23-17.png)

- Concrete Client

```java
public class ConcreteClient {
    private ConcreteLogic concreteLogic;

    public ConcreteClient(final ConcreteLogic concreteLogic) {
        this.concreteLogic = concreteLogic;
    }

    public void execute() {
        concreteLogic.operation();
    }
}
```

- Test

```java
@DisplayName("프록시 적용 전")
@Test
void noProxy() {
    final ConcreteLogic concreteLogic = new ConcreteLogic();
    final ConcreteClient client = new ConcreteClient(concreteLogic);
    client.execute();
}
```


### 예제 2

> **클래스 기반 프록시 도입**

- 지금까지 인터페이스를 기반으로 프록시를 도입했다.
- 그러나 자바의 다형성은 인터페이스를 구현하든, 아니면 클래스를 상속하든 상위 타입만 맞으면 다형성이 적용된다.
- 쉽게 이야기해서 인터페이스가 없어도 프록시를 만들 수 있다는 것이다.
- 그래서 이번에는 인터페이스가 아니라 클래스를 기반으로 상속을 받아서 프록시를 만들어보도록 하자.

![](/images/2022-05-03-01-27-03.png)


- TimeProxy

```java
@Slf4j
public class TimeProxy extends ConcreteLogic {
    private ConcreteLogic target;

    public TimeProxy(final ConcreteLogic target) {
        this.target = target;
    }

    @Override // Override를 통한 다형성 적용
    public String operation() {
        log.info("TimeDecorator 실행");
        final long startTime = System.currentTimeMillis();

        final String result = target.operation();

        final long endTime = System.currentTimeMillis();

        final long resultTime = endTime - startTime;

        log.info("TimeDecorator 종료. resultTime = {}ms", resultTime);

        return result;
    }
}
```

- Test

```java
@DisplayName("TimeProxy 추가")
@Test
void addProxy() {
    final ConcreteLogic concreteLogic = new ConcreteLogic();
    final TimeProxy timeProxy = new TimeProxy(concreteLogic);
    final ConcreteClient client = new ConcreteClient(timeProxy);
    client.execute();
}
```

- Result

```log
01:29:49.429 [main] INFO hello.proxy.pureproxy.concreteproxy.code.TimeProxy - TimeDecorator 실행
01:29:49.431 [main] INFO hello.proxy.pureproxy.concreteproxy.code.ConcreteLogic - ConcreteLogic 실행
01:29:49.431 [main] INFO hello.proxy.pureproxy.concreteproxy.code.TimeProxy - TimeDecorator 종료. resultTime = 0ms
```


- TimeProxy는 시간을 측정하는 부가 기능을 제공한다.
- 그리고 인터페이스가 아니라 ConcreteLogic을 **상속**받아서 만든다.
- 여기서 핵심은 ConcreteClient 생성자에 concreteLogic이 아니라 `timeProxy`를 주입하는 부분이다.
- `ConcreteClient` 는 `ConcreteLogic` 을 의존하는데, 다형성에 의해 `ConcreteLogic`에 `concreteLogic` 도 들어갈 수 있고, `timeProxy` 도 들어갈 수 있다.
- 실행결과를 보면 인터페이스가 없어도 클래스 기반의 프록시가 잘 적용된 것을 확인할 수 있다.

> 참고

- 자바 언어에서 다형성은 인터페이스나 클래스를 구분하지 않고 모두 적용된다.
- 해당 타입과 그 하위 타입은 모두 다형성의 대상이 된다.
- 인터페이스가 없어도 프록시가 가능하다는 걸 짚고 넘어가자.


